### 英语学习

#### 3. The Programming Interface
```
What functions do we need an operating system to provide applications?
1. Process management. Can a program create an instance of another program? Wait
for it to complete? Stop or resume another running program? Send it an asynchronous
event?
2. Input/output. How do processes communicate with devices attached to the computer
and through them to the physical world? Can processes communicate with each
other?
3. Thread management. Can we create multiple activities or threads that share memory
or other resources within a process? Can we stop and start threads? How do we
synchronize their use of shared data structures?
4. Memory management. Can a process ask for more (or less) memory space? Can it
share the same physical memory region with other processes?
5. File systems and storage. How does a process store the user’s data persistently so
that it can survive machine crashes and disk failures? How does the user name and
organize their data?
6. Networking and distributed systems. How do processes communicate with
processes on other computers? How do processes on different computers coordinate
their actions despite machine crashes and network problems?
7. Graphics and window management. How does a process control pixels on its
portion of the screen? How does a process make use of graphics accelerators?
8. Authentication and security. What permissions does a user or a program have, and
how are these permissions kept up to date? On what basis do we know the user (or
program) is who they say they are?

persistently
美[pɚˈsɪstəntlɪ]
adv. 坚持地；固执地

coordinate
美[ koʊˈɔːrdɪneɪt]
v. (使)协调；搭配

despite
美[dɪˈspaɪt]
prep. 尽管

portion
美[ˈpɔːrʃn]
n. 一部分
```

```
3.1 Process Management

A different approach is to allow user programs to create and manage their own processes.
This has fostered a blizzard of innovation. Today, programs that create and manage
processes include window managers, web servers, web browsers, shell command line
interpreters, source code control systems, databases, compilers, and document
preparation systems. We could go on, but you get the idea. If creating a process is
something a process can do, then anyone can build a new version of any of these
applications, without recompiling the kernel or forcing anyone else to use it.

approach
美[əˈproʊtʃ]
v. 对付，处理

foster
美[ˈfɑːstər]
v. 促进，鼓励

innovation
美[ˌɪnəˈveɪʃn]
n. 改革，创新

interpreter
美[ɪnˈtɜːrprətər]
n. 解释者
```

```
3.1.1 Windows Process Management

Unfortunately, there are quite a few aspects of the process that the parent might like to
control, such as: its privileges, where it sends its input and output, what it should store its
files, what to use as a scheduling priority, and so forth. We cannot trust the child process
itself to set its own privileges and priority, and it would be inconvenient to expect every
application to include code for figuring out its context. So the real interface to
CreateProcess is quite a bit more complicated in practice.

privilege
美[ˈprɪvəlɪdʒ]
n. 特权

inconvenient
美[ˌɪnkənˈvinjənt]
adj. 不方便的；打扰人的

complicated
美[ˈkɑːmplɪkeɪtɪd]
adj. 复杂的
```

```
3.1.2 UNIX Process Management

Further, in both Windows and UNIX, handles are reference counted. Whenever the kernel returns a handle, it bumps a reference counter, and whenever the process releases a handle (or exits), the reference counter is decremented. UNIX fork sets the process ID reference count to two, one for the parent and one for the child. The underlying data structure, the PCB, is reclaimed only when the reference count goes to zero, that is, when both the parent and child terminate.

bump
美[bʌmp]
v. 碰撞；引起

reclaim
美[rɪˈkleɪm]
vt. 回收再利用
```

```
3.2 Input/Output

The Internet has a similar facility to UNIX pipes called TCP (Transmission Control
Protocol). Where UNIX pipes connect processes on the same machine, TCP provides
a bi-directional pipe between two processes running on different machines. In TCP,
data is written as a sequence of bytes on one machine and read out as the same
sequence on the other machine.

facility
美[fəˈsɪləti]
n. 设施

bi-directional
美['bɪdɪr'ekʃənl]
adj. 双流向的

sequence
美[ˈsiːkwəns]
n. [数]数列，序列
```

```
3.3 Case Study: Implementing a Shell

use a pipe to connect two programs together, so that the output of one is the input of
another. This is called a producer-consumer relationship. For example, in the C-compiler, 
the output of the preprocessor is sent to the parser, and the output of the
parser is sent to the code-generator and then to the assembler. In the standard UNIX
shell, a pipe connecting two programs is signified by a “|” symbol, as in: “cpp file.c |
cparse | cgen | as > file.o”. In this case the shell creates four separate child processes,
each connected by pipes to its predecessor and successor. Each of the phases can
run in parallel, with the parent waiting for all of them to finish.

signified
美[ˈsɪɡnəˌfaɪd]
v. 表示…的意思

phase
美[feɪz]
n. 阶段

parallel
美[ˈpærəlel]
adj. 并行的
```

```
3.4 Case Study: Interprocess Communication

Three widely used forms of interprocess communication are:
1. Producer-consumer.
2. Client-server.
3. File system.
```